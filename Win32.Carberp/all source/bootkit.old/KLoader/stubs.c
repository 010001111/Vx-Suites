//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// KLoader project
//	
// module: 
//	stubs.c
// created: 
//	april 2011
// description: 
//	Kernel-mode loader for user images. Loader APC stubs.

#include <ntddk.h>
#include "ntddkex.h"
#include "pesup.h"
#include "kloader.h"

//
//	APC function. Initializes mapped image of a DLL: processes import, restores section protection. Executes image entry.
VOID _stdcall LoadDllApcStub(
				   PLOADER_CONTEXT	LdrCtx,
				   PVOID			SystemArgument1,
				   PVOID			SystemArgument2
				   )
{
	HANDLE	hModule;
	PCHAR	ImageBase;


	if (ImageBase = (PCHAR)LdrCtx->ImageBase)
	{
		NTSTATUS		ntStatus = STATUS_SUCCESS;
		FUNC_DLL_MAIN	pDllMain;
		FUNC_APP_ENTRY	AppEntryPoint;

		// Initializing DLL image
		PIMAGE_NT_HEADERS Pe = (PIMAGE_NT_HEADERS)(ImageBase + ((PIMAGE_DOS_HEADER)ImageBase)->e_lfanew);
		PIMAGE_SECTION_HEADER	Section = IMAGE_FIRST_SECTION(Pe);
		ULONG	i, OldProtect, NumberSections = Pe->FileHeader.NumberOfSections;

		// Resolving module import
		ULONG   ImportStartRVA;
		PCHAR   ModuleName;
		PVOID	ImportedModuleBase = NULL;
		PIAT_ENTRY	pIatEntry = NULL;
		PIMAGE_IMPORT_DESCRIPTOR pImportDesc;

		// Get the import table RVA from the data dir
		if (ImportStartRVA = Pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress)
		{
			pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)(ImageBase + ImportStartRVA);

			// Find the import descriptor containing references to callee's functions
			for (; pImportDesc->Name; pImportDesc++) 
			{	
				ULONG NameLen = 0;
				ModuleName = ImageBase + pImportDesc->Name;

				while(ModuleName[NameLen])
				{
					LdrCtx->wDllPath[NameLen] = (WCHAR)ModuleName[NameLen];
					NameLen += 1;
				}
				LdrCtx->uDllPath.Length = (USHORT)(NameLen*sizeof(WCHAR));
				LdrCtx->uDllPath.MaximumLength = (USHORT)((NameLen+1)*sizeof(WCHAR));
				LdrCtx->uDllPath.Buffer = (PWSTR)&LdrCtx->wDllPath;
					
				ntStatus = ((FUNC_LOAD_LIBRARY)LdrCtx->Import.pLdrLoadDll)(NULL, 0, &LdrCtx->uDllPath, &ImportedModuleBase);
				if (NT_SUCCESS(ntStatus))
				{
					ULONG   rvaINT = pImportDesc->OriginalFirstThunk;
					ULONG   rvaIAT = pImportDesc->FirstThunk;
					PIAT_ENTRY	pIatEntry = NULL;
					PIMAGE_IMPORT_BY_NAME   pOrdinalName;
					PIMAGE_THUNK_DATA		pINT;
					PIMAGE_THUNK_DATA		pIAT;
					IAT_ENTRY				IatEntry;
					USHORT					Ordinal = 0;

					if ( rvaINT == 0 )   // No Characteristics field?
						rvaINT = rvaIAT;
	     
					if ( rvaINT != 0 )   // No FirstThunk field?  Ooops!!!
					{
						// Adjust the pointer to point where the tables are in the mem mapped file.
						pINT = (PIMAGE_THUNK_DATA)(ImageBase + rvaINT);
						pIAT = (PIMAGE_THUNK_DATA)(ImageBase + rvaIAT);

						while (TRUE) // Loop forever (or until we break out)
						{	
							if (pINT->u1.AddressOfData == 0)
								break;

							if (IMAGE_SNAP_BY_ORDINAL(pINT->u1.Ordinal) == FALSE)
								pOrdinalName = (PIMAGE_IMPORT_BY_NAME)(ImageBase + (ULONG)pINT->u1.AddressOfData);
							else if (pINT->u1.Ordinal >= (ULONG_PTR)ImageBase && pINT->u1.Ordinal < ((ULONG_PTR)ImageBase + Pe->OptionalHeader.SizeOfImage))
								pOrdinalName = (PIMAGE_IMPORT_BY_NAME)((ULONG_PTR)pINT->u1.AddressOfData);
							else
							{
								pOrdinalName = NULL;
								Ordinal = (USHORT)IMAGE_ORDINAL(pINT->u1.Ordinal);
							}
								
							if (pOrdinalName)
							{
								NameLen = 0;
								while(pOrdinalName->Name[NameLen])
									NameLen += 1;

								LdrCtx->uDllPath.Length = (USHORT)NameLen;
								LdrCtx->uDllPath.MaximumLength = (USHORT)(NameLen + 1);
								LdrCtx->uDllPath.Buffer = (PWSTR)&pOrdinalName->Name;
								pOrdinalName = (PIMAGE_IMPORT_BY_NAME)&LdrCtx->uDllPath;
							}

							ntStatus = ((FUNC_PROC_ADDRESS)LdrCtx->Import.pLdrGetProcedureAddress)(ImportedModuleBase, (PANSI_STRING)pOrdinalName, Ordinal, (PVOID*)&IatEntry);
							if (NT_SUCCESS(ntStatus))
							{
								pIatEntry = &pIAT->u1.Function;
								*pIatEntry = IatEntry;
							}
							else
							{
								ntStatus = STATUS_PROCEDURE_NOT_FOUND;
								break;
							}

							pINT++;         // advance to next thunk
							pIAT++;         // advance to next thunk
						} // while (TRUE)	
					}	// if ( rvaINT != 0 ) 
				}	// if (NT_SUCCESS(ntStatus))
				else
				{
					ntStatus = STATUS_INVALID_IMPORT_OF_NON_DLL;
					break;
				}
			} // for (; pImportDesc->Name; pImportDesc++) 
		}	// if (ImportStartRVA = Pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress)


		if (NT_SUCCESS(ntStatus))
		{
			ULONG_PTR	tSize = (ULONG_PTR)Pe->OptionalHeader.SizeOfHeaders;
			// Restoring sections' protection
			ntStatus = ((FUNC_PROTECT_MEM)LdrCtx->Import.pNtProtectVirtualMemory)((HANDLE)-1, (PVOID*)&ImageBase, &tSize, PAGE_READWRITE, &OldProtect);
			for (i=0; (i<NumberSections && NT_SUCCESS(ntStatus)); i++)
			{
				ULONG	NewProtect = 0;
				PVOID	BaseAddress;
	
				if (Section->Characteristics & IMAGE_SCN_MEM_EXECUTE)
				{
					if (Section->Characteristics & IMAGE_SCN_MEM_WRITE)
						NewProtect = PAGE_EXECUTE_READWRITE;
					else
						NewProtect = PAGE_EXECUTE_READ;
				} 
				else if (Section->Characteristics & IMAGE_SCN_MEM_READ)
				{
					if (Section->Characteristics & IMAGE_SCN_MEM_WRITE)
						NewProtect = PAGE_READWRITE;
					else
						NewProtect = PAGE_READONLY;
				}
				else 
					NewProtect = PAGE_READWRITE;

				tSize = (ULONG_PTR)Section->Misc.VirtualSize;
				BaseAddress = (PVOID)(ImageBase + Section->VirtualAddress);
				ntStatus = ((FUNC_PROTECT_MEM)LdrCtx->Import.pNtProtectVirtualMemory)(NtCurrentProcess(), &BaseAddress, &tSize, NewProtect, &OldProtect);
				Section += 1;
			}	// for (i=0; i<NumberSections; i++)
		
			if (NT_SUCCESS(ntStatus))
			{
				// Calling DLL entry point
				pDllMain = (FUNC_DLL_MAIN)(ImageBase + Pe->OptionalHeader.AddressOfEntryPoint);
				(pDllMain)(ImageBase, DLL_PROCESS_ATTACH, NULL);
			}	// if (NT_SUCCESS(ntStatus))
		}	// if (NT_SUCCESS(ntStatus))
	}	// if (ImageBase = LdrCtx->ImageBase)
	else
		// Loading DLL by name
		((FUNC_LOAD_LIBRARY)LdrCtx->Import.pLdrLoadDll)(NULL, 0, &LdrCtx->uDllPath, &hModule);


	UNREFERENCED_PARAMETER(SystemArgument1);
	UNREFERENCED_PARAMETER(SystemArgument2);
}


#ifdef _M_AMD64

// This is normal LoadDllApcStub() function compiled for x86.
UCHAR	LoadDllApcStubWow64[] = {
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x24, 0x53, 0x8B, 0x5D, 0x08, 0x8B, 0x93, 0x30, 0x08, 
	0x00, 0x00, 0x85, 0xD2, 0x89, 0x55, 0x08, 0x0F, 0x84, 0x48, 0x02, 0x00, 0x00, 0x8B, 0x4A, 0x3C, 
	0x0F, 0xB7, 0x44, 0x11, 0x14, 0x03, 0xCA, 0x8D, 0x44, 0x08, 0x18, 0x89, 0x45, 0xE4, 0x0F, 0xB7, 
	0x41, 0x06, 0x89, 0x45, 0xEC, 0xC7, 0x45, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x81, 0x80, 0x00, 
	0x00, 0x00, 0x85, 0xC0, 0x56, 0x57, 0x89, 0x4D, 0xF8, 0x0F, 0x84, 0x1F, 0x01, 0x00, 0x00, 0x8B, 
	0x74, 0x10, 0x0C, 0x85, 0xF6, 0x8D, 0x3C, 0x10, 0x89, 0x7D, 0xFC, 0x0F, 0x84, 0x0D, 0x01, 0x00, 
	0x00, 0x8A, 0x04, 0x16, 0x03, 0xF2, 0x33, 0xC9, 0x84, 0xC0, 0x74, 0x18, 0x8D, 0x93, 0x50, 0x08, 
	0x00, 0x00, 0x66, 0x0F, 0xBE, 0xC0, 0x41, 0x66, 0x89, 0x02, 0x8A, 0x04, 0x0E, 0x83, 0xC2, 0x02, 
	0x84, 0xC0, 0x75, 0xEE, 0x8D, 0x04, 0x09, 0x8D, 0x8B, 0x48, 0x08, 0x00, 0x00, 0x8D, 0x55, 0xF0, 
	0x52, 0x66, 0x89, 0x01, 0x83, 0xC0, 0x02, 0x51, 0x66, 0x89, 0x83, 0x4A, 0x08, 0x00, 0x00, 0x6A, 
	0x00, 0x8D, 0x83, 0x50, 0x08, 0x00, 0x00, 0x6A, 0x00, 0x89, 0x83, 0x4C, 0x08, 0x00, 0x00, 0xFF, 
	0x13, 0x85, 0xC0, 0x0F, 0x8C, 0xA3, 0x01, 0x00, 0x00, 0x8B, 0x0F, 0x85, 0xC9, 0x8B, 0x77, 0x10, 
	0xC7, 0x45, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0A, 0x85, 0xF6, 0x8B, 0xCE, 0x0F, 0x84, 0x1E, 
	0x01, 0x00, 0x00, 0x8B, 0x55, 0x08, 0x8D, 0x3C, 0x11, 0x8B, 0x0F, 0x03, 0xF2, 0x85, 0xC9, 0x74, 
	0x6E, 0x0F, 0x88, 0xDB, 0x00, 0x00, 0x00, 0x03, 0xCA, 0x85, 0xC9, 0x74, 0x35, 0x8A, 0x51, 0x02, 
	0x83, 0xC1, 0x02, 0x33, 0xC0, 0x84, 0xD2, 0x74, 0x10, 0x8D, 0xA4, 0x24, 0x00, 0x00, 0x00, 0x00, 
	0x8A, 0x54, 0x01, 0x01, 0x40, 0x84, 0xD2, 0x75, 0xF7, 0x8D, 0x93, 0x48, 0x08, 0x00, 0x00, 0x66, 
	0x89, 0x02, 0x40, 0x89, 0x8B, 0x4C, 0x08, 0x00, 0x00, 0x66, 0x89, 0x83, 0x4A, 0x08, 0x00, 0x00, 
	0x8B, 0xCA, 0x8B, 0x55, 0xF4, 0x8D, 0x45, 0xE8, 0x50, 0x8B, 0x45, 0xF0, 0x52, 0x51, 0x50, 0xFF, 
	0x53, 0x08, 0x85, 0xC0, 0x0F, 0x8C, 0xAA, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xE8, 0x89, 0x0E, 0x8B, 
	0x4F, 0x04, 0x8B, 0x55, 0x08, 0x83, 0xC7, 0x04, 0x83, 0xC6, 0x04, 0x85, 0xC9, 0x75, 0x92, 0x8B, 
	0x7D, 0xFC, 0x8B, 0x77, 0x20, 0x83, 0xC7, 0x14, 0x85, 0xF6, 0x89, 0x7D, 0xFC, 0x0F, 0x85, 0xFE, 
	0xFE, 0xFF, 0xFF, 0x85, 0xC0, 0x0F, 0x8C, 0xF1, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xF8, 0x8B, 0x51, 
	0x54, 0x8D, 0x45, 0xE0, 0x50, 0x6A, 0x04, 0x8D, 0x4D, 0xFC, 0x89, 0x55, 0xFC, 0x51, 0x8D, 0x55, 
	0x08, 0x52, 0x6A, 0xFF, 0xFF, 0x53, 0x10, 0x8B, 0x4D, 0xEC, 0x33, 0xFF, 0x85, 0xC9, 0x0F, 0x86, 
	0xB2, 0x00, 0x00, 0x00, 0x8B, 0x75, 0xE4, 0x83, 0xC6, 0x24, 0x8D, 0x9B, 0x00, 0x00, 0x00, 0x00, 
	0x85, 0xC0, 0x0F, 0x8C, 0xB4, 0x00, 0x00, 0x00, 0x8B, 0x06, 0xA9, 0x00, 0x00, 0x00, 0x20, 0x74, 
	0x48, 0x25, 0x00, 0x00, 0x00, 0x80, 0xF7, 0xD8, 0x1B, 0xC0, 0x83, 0xE0, 0x20, 0x83, 0xC0, 0x20, 
	0xEB, 0x54, 0x3B, 0xCA, 0x72, 0x10, 0x8B, 0x45, 0xF8, 0x8B, 0x40, 0x50, 0x03, 0xC2, 0x3B, 0xC8, 
	0x0F, 0x82, 0x13, 0xFF, 0xFF, 0xFF, 0x66, 0x8B, 0x17, 0x33, 0xC9, 0x66, 0x89, 0x55, 0xF4, 0xE9, 
	0x3E, 0xFF, 0xFF, 0xFF, 0x8B, 0x55, 0x08, 0xB8, 0x7A, 0x00, 0x00, 0xC0, 0xE9, 0x5E, 0xFF, 0xFF, 
	0xFF, 0x8B, 0x55, 0x08, 0xE9, 0x59, 0xFF, 0xFF, 0xFF, 0xA9, 0x00, 0x00, 0x00, 0x40, 0x74, 0x11, 
	0x25, 0x00, 0x00, 0x00, 0x80, 0xF7, 0xD8, 0x1B, 0xC0, 0x83, 0xE0, 0x02, 0x83, 0xC0, 0x02, 0xEB, 
	0x05, 0xB8, 0x04, 0x00, 0x00, 0x00, 0x8B, 0x4E, 0xE4, 0x8B, 0x56, 0xE8, 0x89, 0x4D, 0xFC, 0x03, 
	0x55, 0x08, 0x8D, 0x4D, 0xE0, 0x51, 0x50, 0x89, 0x55, 0xE4, 0x8D, 0x55, 0xFC, 0x52, 0x8D, 0x45, 
	0xE4, 0x50, 0x6A, 0xFF, 0xFF, 0x53, 0x10, 0x8B, 0x4D, 0xEC, 0x83, 0xC6, 0x28, 0x47, 0x3B, 0xF9, 
	0x0F, 0x82, 0x5A, 0xFF, 0xFF, 0xFF, 0x85, 0xC0, 0x7C, 0x12, 0x8B, 0x4D, 0xF8, 0x8B, 0x45, 0x08, 
	0x8B, 0x51, 0x28, 0x6A, 0x00, 0x6A, 0x01, 0x50, 0x03, 0xD0, 0xFF, 0xD2, 0x5F, 0x5E, 0x5B, 0x8B, 
	0xE5, 0x5D, 0xC2, 0x0C, 0x00, 0x8D, 0x45, 0xDC, 0x50, 0x8D, 0x8B, 0x48, 0x08, 0x00, 0x00, 0x51, 
	0x6A, 0x00, 0x6A, 0x00, 0xFF, 0x13, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x0C, 0x00
};

#endif	// _M_AMD64